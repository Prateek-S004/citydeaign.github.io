<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            color: #333;
        }
        h2 {
            color: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
        ul {
            margin: 10px 0;
        }
        ul li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h2>1. Problems in Nature (Iteration, Recursion, Backtracking)</h2>
    <p>Nature's processes beautifully align with algorithmic concepts. Here's how:</p>
    <h3>Iteration:</h3>
    <ul>
        <li><strong>Water cycle:</strong> Evaporation &rarr; condensation &rarr; precipitation &rarr; repeat.</li>
        <li><strong>Animal migration:</strong> Seasonal movements of birds, fishes, and mammals in a predictable loop.</li>
    </ul>
    <h3>Recursion:</h3>
    <ul>
        <li><strong>Tree branching:</strong> From main trunk &rarr; smaller branches &rarr; twigs.</li>
        <li><strong>Snowflakes:</strong> Fractal patterns that repeat at smaller scales.</li>
        <li><strong>DNA replication:</strong> Each process calls itself to replicate accurately.</li>
    </ul>
    <h3>Backtracking:</h3>
    <ul>
        <li><strong>Maze-solving by ants or rats:</strong> Exploring paths and retreating when blocked.</li>
        <li><strong>Foraging behavior:</strong> Animals retry paths to locate food sources.</li>
    </ul>

    <h2>2. Space and Time Efficiency</h2>
    <h3>Time Complexity:</h3>
    <ul>
        <li><strong>O(1):</strong> Instant (e.g., accessing an array element).</li>
        <li><strong>O(n):</strong> Linear (e.g., summing elements in a list).</li>
        <li><strong>O(log n):</strong> Logarithmic (e.g., binary search).</li>
    </ul>
    <h3>Space Complexity:</h3>
    <ul>
        <li><strong>Optimal:</strong> Small variables and no redundant storage (e.g., in-place sorting).</li>
        <li><strong>Bad:</strong> Excessive memory use for intermediate steps.</li>
    </ul>

    <h2>3. Takeaway from Different Design Principles (Chapter 2)</h2>
    <table>
        <thead>
            <tr>
                <th>Principle</th>
                <th>Explanation</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Divide and Conquer</td>
                <td>Solve problems by dividing into smaller sub-problems.</td>
                <td>Sorting arrays via QuickSort.</td>
            </tr>
            <tr>
                <td>Pattern Spotting</td>
                <td>Recognize repeated structures to generalize solutions.</td>
                <td>Finding symmetry in architecture (Indian forts).</td>
            </tr>
            <tr>
                <td>Essential Focus</td>
                <td>Simplify by ignoring unnecessary details.</td>
                <td>Modeling geometric shapes without worrying about texture.</td>
            </tr>
            <tr>
                <td>Exploration Strategies</td>
                <td>Dive deep or explore level-wise.</td>
                <td>DFS for depth-first and BFS for breadth-level exploration.</td>
            </tr>
            <tr>
                <td>Efficient Filtering</td>
                <td>Remove irrelevant data early on.</td>
                <td>Pruning invalid options in N-Queens problem.</td>
            </tr>
            <tr>
                <td>Delayed Updates</td>
                <td>Postpone changes until necessary.</td>
                <td>Lazy propagation in segment trees.</td>
            </tr>
            <tr>
                <td>Window Optimization</td>
                <td>Efficiently process overlapping data ranges.</td>
                <td>Sliding windows for subarray sums.</td>
            </tr>
            <tr>
                <td>Tree Balancing</td>
                <td>Maintain balanced hierarchies for faster queries.</td>
                <td>AVL trees use rotations to keep balance.</td>
            </tr>
            <tr>
                <td>Pre-Calculated Results</td>
                <td>Cache solutions to avoid recomputation.</td>
                <td>Fibonacci sequence using memoization.</td>
            </tr>
        </tbody>
    </table>

    <h2>4. Hierarchical Data and Tree Structures</h2>
    <table>
        <thead>
            <tr>
                <th>Tree Type</th>
                <th>Characteristics</th>
                <th>Use Case</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Binary Search Tree (BST)</td>
                <td>Keeps data sorted but unbalanced ones can slow down.</td>
                <td>Fast search in databases.</td>
            </tr>
            <tr>
                <td>AVL Tree</td>
                <td>Balanced BST with rotations ensuring O(log n).</td>
                <td>Efficient for real-time updates.</td>
            </tr>
            <tr>
                <td>Red-Black Tree</td>
                <td>Less strict balancing with faster insertions/deletions.</td>
                <td>Used in libraries like <code>std::map</code> in C++.</td>
            </tr>
            <tr>
                <td>Heap</td>
                <td>Priority-based, max/min heap for efficient access.</td>
                <td>Priority queues, like task schedulers.</td>
            </tr>
            <tr>
                <td>Trie</td>
                <td>Stores strings efficiently with prefix sharing.</td>
                <td>Autocomplete systems in search engines.</td>
            </tr>
        </tbody>
    </table>

    <h2>5. Difference Between Trees and Graphs</h2>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Tree</th>
                <th>Graph</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Structure</td>
                <td>Hierarchical, one root, no cycles.</td>
                <td>Networked, can have cycles or multiple roots.</td>
            </tr>
            <tr>
                <td>Traversal Methods</td>
                <td>In-order, pre-order, post-order.</td>
                <td>BFS (level-by-level), DFS (depth-first).</td>
            </tr>
            <tr>
                <td>Applications</td>
                <td>File systems, organizational hierarchies.</td>
                <td>Social networks, road maps, communication networks.</td>
            </tr>
        </tbody>
    </table>

    <h2>6. Sorting and Searching Algorithms</h2>
    <h3>Sorting:</h3>
    <ul>
        <li><strong>QuickSort:</strong> Divide array, sort sub-arrays, recombine.</li>
        <li><strong>MergeSort:</strong> Divide and merge sorted parts.</li>
    </ul>
    <h3>Searching:</h3>
    <ul>
        <li><strong>Binary Search:</strong> Fast, works only on sorted data. O(log n).</li>
        <li><strong>Linear Search:</strong> Slower but works on any data. O(n).</li>
    </ul>

    <h2>7. Importance of Graph Algorithms: Spanning Trees and Shortest Paths</h2>
    <h3>Spanning Trees:</h3>
    <ul>
        <li><strong>Prim’s/Kruskal’s Algorithm:</strong> Efficient for road networks, minimizing construction costs.</li>
    </ul>
    <h3>Shortest Paths:</h3>
    <ul>
        <li><strong>Dijkstra's:</strong> GPS routing and network communication.</li>
        <li><strong>Bellman-Ford:</strong> Handles negative edge weights in financial analysis.</li>
    </ul>

    <h2>8. Algorithm Design Techniques</h2>
    <ul>
        <li><strong>Divide and Conquer:</strong> Break into smaller problems (e.g., MergeSort).</li>
        <li><strong>Dynamic Programming:</strong> Reuse overlapping solutions (e.g., Fibonacci).</li>
        <li><strong>Greedy Algorithms:</strong> Optimal step-by-step choices (e.g., Huffman coding).</li>
        <li><strong>Backtracking:</strong> Explore all paths, retract when stuck (e.g., Sudoku).</li>
    </ul>
</body>
</html>
