<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            color: #333;
        }
        header {
            text-align: center;
            padding: 20px;
            background-color: #0056b3;
            color: #fff;
        }
        header h1 {
            margin: 0;
        }
        main {
            padding: 20px;
        }
        section {
            margin-bottom: 20px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        section h2 {
            color: #0056b3;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        footer {
            text-align: center;
            padding: 10px;
            background-color: #0056b3;
            color: #fff;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <header>
        <h1>Course Learning Reflections</h1>
    </header>

    <main>
        <section>
            <h2>1. Problems in Nature (Iteration, Recursion, Backtracking)</h2>
            <ul>
                <li><strong>Iteration:</strong> Processes like the water cycle (evaporation, condensation, precipitation) and seasonal migrations repeat in cycles.</li>
                <li><strong>Recursion:</strong> Found in tree branching, fractals (like snowflakes), and the self-replicating process of DNA duplication.</li>
                <li><strong>Backtracking:</strong> Seen in maze-solving or animal foraging where paths are retraced if they lead to dead ends.</li>
            </ul>
        </section>

        <section>
            <h2>2. Space and Time Efficiency</h2>
            <p>Efficient algorithms save time and memory, helping systems run faster and handle large data effectively. Time complexity measures the number of operations (e.g., O(1), O(n), O(log n)), while space complexity tracks memory usage. Optimizing both is essential for scalable software.</p>
        </section>

        <section>
            <h2>3. Hierarchical Data and Tree Structures</h2>
            <p>Trees efficiently manage hierarchical data. Here are some key structures:</p>
            <ul>
                <li><strong>Binary Search Tree (BST):</strong> Keeps data sorted, making searches faster, but can become inefficient if unbalanced.</li>
                <li><strong>AVL Tree:</strong> A balanced BST that uses rotations to ensure fast operations.</li>
                <li><strong>Red-Black Tree:</strong> Another balanced tree, slightly less strict but faster for insertions/deletions.</li>
                <li><strong>Heap:</strong> Useful for priority-based tasks, like finding the maximum or minimum value.</li>
                <li><strong>Trie:</strong> Specialized for storing and searching strings, ideal for autocomplete systems.</li>
            </ul>
        </section>

        <section>
            <h2>4. Array Query Algorithms and Their Applications</h2>
            <p>Efficient data retrieval is crucial for modern systems. Key algorithms include:</p>
            <ul>
                <li><strong>Binary Search:</strong> Quickly locates elements in sorted arrays (O(log n)).</li>
                <li><strong>Prefix Sums:</strong> Speeds up range-sum calculations by precomputing cumulative totals.</li>
                <li><strong>Segment Trees:</strong> Handles range queries and updates efficiently, used in databases and game development.</li>
            </ul>
        </section>

        <section>
            <h2>5. Difference Between Trees and Graphs</h2>
            <p>Both trees and graphs organize data but differ in structure:</p>
            <ul>
                <li><strong>Tree:</strong> A hierarchical structure with one root and no cycles. Traversal methods include in-order, pre-order, and post-order.</li>
                <li><strong>Graph:</strong> A network of interconnected nodes, allowing cycles and multiple paths. Traversal uses BFS (level-by-level) or DFS (deep exploration).</li>
            </ul>
        </section>

        <section>
            <h2>6. Sorting and Searching Algorithms</h2>
            <p>Efficient sorting and searching streamline data organization and retrieval:</p>
            <ul>
                <li><strong>Sorting:</strong> Algorithms like QuickSort and MergeSort arrange data in specific orders, enabling better data management.</li>
                <li><strong>Searching:</strong> Binary search excels in sorted arrays, while linear search works for unsorted data.</li>
            </ul>
            <p>These are essential for databases, logistics, and optimizing user experiences, like faster search results or better inventory management.</p>
        </section>
    </main>

</div> <!-- End of container -->
</body>
</html>
