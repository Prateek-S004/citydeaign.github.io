<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            color: #333;
        }
        header {
            text-align: center;
            padding: 20px;
            background-color: #0056b3;
            color: #fff;
        }
        header h1 {
            margin: 0;
        }
        main {
            padding: 20px;
        }
        section {
            margin-bottom: 20px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        section h2 {
            color: #0056b3;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        footer {
            text-align: center;
            padding: 10px;
            background-color: #0056b3;
            color: #fff;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <header>
        <h1>Course Learning Reflections</h1>
    </header>

    <main>
        <section>
            <h2>1. Problems in Nature (Iteration, Recursion, Backtracking)</h2>
            <ul>
                <li><strong>Iteration:</strong> Seasonal cycles, daily routines.</li>
                <li><strong>Recursion:</strong> Tree branches, fractals in nature.</li>
                <li><strong>Backtracking:</strong> Animal foraging or maze navigation.</li>
            </ul>
        </section>

        <section>
            <h2>2. Space and Time Efficiency</h2>
            <p>Efficiency in algorithms is measured by how fast (time complexity) and how much memory (space complexity) they use. Common orders of growth include O(1), O(n), O(log n), and O(n²). Efficient algorithms save both time and resources.</p>
        </section>

        <section>
            <h2>3. Hierarchical Data and Tree Structures</h2>
            <p>Trees like BST, AVL, Red-Black, and Trie optimize searching, sorting, and hierarchical data organization. Heaps are great for priority queues, while 2-3 trees ensure balanced growth for efficient lookup.</p>
        </section>

        <section>
            <h2>4. Array Query Algorithms and Their Implications</h2>
            <p>Array query algorithms like binary search, prefix sums, and segment trees help in fast data retrieval and manipulation. They’re crucial in databases, search engines, and real-time systems.</p>
        </section>

        <section>
            <h2>5. Difference Between Trees and Graphs</h2>
            <p>Trees are hierarchical (one root), while graphs are interconnected with no specific root. Tree traversal includes in-order, pre-order, and post-order. Graphs use BFS and DFS for exploring paths and networks.</p>
        </section>

        <section>
            <h2>6. Sorting and Searching Algorithms</h2>
            <p>Sorting algorithms (e.g., quicksort, mergesort) arrange data systematically. Searching algorithms (e.g., linear search, binary search) quickly locate items. They’re essential in databases, file systems, and real-world logistics like organizing products or customer searches.</p>
        </section>
    </main>

    <footer>
        <p>Reflection Portfolio by Veeresh S H</p>
    </footer>
</body>
</html>
